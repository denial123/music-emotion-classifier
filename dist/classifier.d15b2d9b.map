{"version":3,"sources":["scripts\\ShapeData.ts","scripts\\classifier.ts"],"names":[],"mappings":"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","file":"classifier.d15b2d9b.map","sourceRoot":"..","sourcesContent":["// Gathers all functions used to make the dataset ok for tensors\r\n\r\nexport class ShapeData {\r\n    makeDatasetForTensors(data: object): Array<Array<any>> {\r\n        let dataInputs = [];\r\n        let dataOutputs = [];\r\n        for (const singleSong in data) {\r\n            let newArray = this.convertObjectToArray(data[singleSong]);\r\n            dataInputs.push(newArray[0]);\r\n            dataOutputs.push(newArray[1]);\r\n        }\r\n        return [\r\n            dataInputs,\r\n            dataOutputs\r\n        ];\r\n    };\r\n\r\n    convertObjectToArray(data: object): Array<Array<any>> {\r\n        // Converts the object to an iterable object\r\n        let singleFeature = [];\r\n        for(let [key, value] of Object.entries(data)) {\r\n            if (!Object.entries)\r\n                Object.entries = function( obj ){\r\n                    var ownProps = Object.keys( obj ),\r\n                        i = ownProps.length,\r\n                        resArray = new Array(i); // preallocate the Array\r\n                    while (i--)\r\n                        resArray[i] = [ownProps[i], obj[ownProps[i]]];\r\n                    if (i<ownProps.length-3) {\r\n                        return resArray;\r\n                    }\r\n                };\r\n            singleFeature.push(value); // add each feature to an array\r\n            // console.log(key, value); // \"first\", \"one\"\r\n        }\r\n        // Returns an array with\r\n        // [0] List of features\r\n        // [1] Label (\"relax\", \"calm\"...)\r\n        return [\r\n            singleFeature.splice(4), // I splice the array because the first values are id, song_name, class and label\r\n            singleFeature.splice(2, 1)\r\n        ]\r\n    };\r\n\r\n\r\n    isIterable(obj) {\r\n        console.log(obj);\r\n        // checks for null and undefined\r\n        if (obj == null) {\r\n            return false;\r\n        }\r\n        return typeof obj[Symbol.iterator] === 'function';\r\n    }\r\n\r\n}","'use strict';\r\n\r\n// Import data\r\nimport * as dataset from \"../data/Emotion_data.json\";\r\nimport * as toClassify from \"../toClassify/Emotion_features.json\";\r\n\r\n// Import functions to convert data\r\nimport * as SD from \"./ShapeData\";\r\nconst ShapeData = new SD.ShapeData;\r\n\r\n\r\n// const Classifier = (p) => {\r\nlet data = {};\r\nlet songsToClassify = {};\r\nlet dataInputs = []; // The output of dataInputs[0] is dataOutputs[0]\r\nlet dataOutputs = []; // \"relax\", \"sad\", \"happy\"...\r\nconst featuresList = [\r\n    \"tempo\",\r\n    \"total_beats\",\r\n    \"average_beats\",\r\n    \"chroma_stft_mean\",\r\n    \"chroma_stft_std\",\r\n    \"chroma_stft_var\",\r\n    \"chroma_cq_mean\",\r\n    \"chroma_cq_std\",\r\n    \"chroma_cq_var\",\r\n    \"chroma_cens_mean\",\r\n    \"chroma_cens_std\",\r\n    \"chroma_cens_var\",\r\n    \"melspectrogram_mean\",\r\n    \"melspectrogram_std\",\r\n    \"melspectrogram_var\",\r\n    \"mfcc_mean\",\r\n    \"mfcc_std\",\r\n    \"mfcc_var\",\r\n    \"mfcc_delta_mean\",\r\n    \"mfcc_delta_std\",\r\n    \"mfcc_delta_var\",\r\n    \"rmse_mean\",\r\n    \"rmse_std\",\r\n    \"rmse_var\",\r\n    \"cent_mean\",\r\n    \"cent_std\",\r\n    \"cent_var\",\r\n    \"spec_bw_mean\",\r\n    \"spec_bw_std\",\r\n    \"spec_bw_var\",\r\n    \"contrast_mean\",\r\n    \"contrast_std\",\r\n    \"contrast_var\",\r\n    \"rolloff_mean\",\r\n    \"rolloff_std\",\r\n    \"rolloff_var\",\r\n    \"poly_mean\",\r\n    \"poly_std\",\r\n    \"poly_var\",\r\n    \"tonnetz_mean\",\r\n    \"tonnetz_std\",\r\n    \"tonnetz_var\",\r\n    \"zcr_mean\",\r\n    \"zcr_std\",\r\n    \"zcr_var\",\r\n    \"harm_mean\",\r\n    \"harm_std\",\r\n    \"harm_var\",\r\n    \"perc_mean\",\r\n    \"perc_std\",\r\n    \"perc_var\",\r\n    \"frame_mean\",\r\n    \"frame_std\",\r\n    \"frame_var\"\r\n]; // all sound features, inputs\r\nlet featuresMinMax = []; // to store the min and max value used for normalizing the inputs\r\n\r\nsetup();\r\n\r\nfunction setup(): void {\r\n\r\n    loadJSON(dataset.default) // We have to use .default to load the url correctly with parcel\r\n        .then((jsonDataset) => {\r\n            data = JSON.parse(jsonDataset);\r\n            // let test = isIterable(data);\r\n            // console.log(test);\r\n            let newData = ShapeData.makeDatasetForTensors(data);\r\n            dataInputs = newData[0];\r\n            dataOutputs = newData[1];\r\n            console.log(dataOutputs);\r\n            // makeInputs();\r\n            return loadJSON(toClassify.default);\r\n        })\r\n        .then((jsonSongs) => {\r\n            songsToClassify = JSON.parse(jsonSongs);\r\n            for (let i=0; i<featuresList.length; i++) {\r\n                getMinMaxValues(featuresList[i]);\r\n            }\r\n            console.log(featuresMinMax);\r\n        })\r\n        .catch((err) => console.log(err));\r\n    // songsToClassify = loadJSON(toClassify, () => {\r\n\r\n}\r\n\r\n\r\n\r\nfunction makeInputs(): void {\r\n    let features = [];\r\n    for (let singleSong of data) {\r\n        for (let singleFeature of data[singleSong]) {\r\n            console.log(data[singleSong][singleFeature]);\r\n        }\r\n    }\r\n}\r\n\r\nfunction loadJSON(url: string): Promise<any> {\r\n\r\n    return new Promise((resolve, reject) => {\r\n        let xobj = new XMLHttpRequest();\r\n        xobj.overrideMimeType(\"application/json\");\r\n        xobj.open('GET', url, true); // Replace 'my_data' with the path to your file\r\n        xobj.onreadystatechange = () => {\r\n            if (xobj.readyState == 4 && xobj.status == 200) {\r\n                resolve(xobj.responseText);\r\n            }\r\n        };\r\n        xobj.send(null);\r\n        xobj.onerror = () => reject(xobj.statusText);\r\n    });\r\n\r\n}\r\n\r\nfunction getMinMaxValues(feature: string): void {\r\n    let maxValue = 0;\r\n    let minValue = 0;\r\n    let counter = 0;\r\n\r\n    for (const song in data) {\r\n        let value = data[song][feature];\r\n        if (counter === 0) {\r\n            maxValue = value;\r\n            minValue = value;\r\n        }\r\n        if (value > maxValue) {\r\n            maxValue = value;\r\n        }\r\n        if (value < minValue) {\r\n            minValue = value;\r\n        }\r\n        counter++;\r\n    }\r\n\r\n    featuresMinMax.push({\r\n        \"feature\": feature,\r\n        \"min\": minValue,\r\n        \"max\": maxValue\r\n    });\r\n}\r\n\r\n\r\n\r\n"]}