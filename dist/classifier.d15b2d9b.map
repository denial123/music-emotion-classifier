{"version":3,"sources":["scripts\\ShapeData.ts","scripts\\classifier.ts"],"names":[],"mappings":"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","file":"classifier.d15b2d9b.map","sourceRoot":"..","sourcesContent":["// Gathers all functions used to make the dataset ok for tensors\r\n\r\nexport class ShapeData {\r\n\r\n    featuresList = [\r\n        \"tempo\",\r\n        \"total_beats\",\r\n        \"average_beats\",\r\n        \"chroma_stft_mean\",\r\n        \"chroma_stft_std\",\r\n        \"chroma_stft_var\",\r\n        \"chroma_cq_mean\",\r\n        \"chroma_cq_std\",\r\n        \"chroma_cq_var\",\r\n        \"chroma_cens_mean\",\r\n        \"chroma_cens_std\",\r\n        \"chroma_cens_var\",\r\n        \"melspectrogram_mean\",\r\n        \"melspectrogram_std\",\r\n        \"melspectrogram_var\",\r\n        \"mfcc_mean\",\r\n        \"mfcc_std\",\r\n        \"mfcc_var\",\r\n        \"mfcc_delta_mean\",\r\n        \"mfcc_delta_std\",\r\n        \"mfcc_delta_var\",\r\n        \"rmse_mean\",\r\n        \"rmse_std\",\r\n        \"rmse_var\",\r\n        \"cent_mean\",\r\n        \"cent_std\",\r\n        \"cent_var\",\r\n        \"spec_bw_mean\",\r\n        \"spec_bw_std\",\r\n        \"spec_bw_var\",\r\n        \"contrast_mean\",\r\n        \"contrast_std\",\r\n        \"contrast_var\",\r\n        \"rolloff_mean\",\r\n        \"rolloff_std\",\r\n        \"rolloff_var\",\r\n        \"poly_mean\",\r\n        \"poly_std\",\r\n        \"poly_var\",\r\n        \"tonnetz_mean\",\r\n        \"tonnetz_std\",\r\n        \"tonnetz_var\",\r\n        \"zcr_mean\",\r\n        \"zcr_std\",\r\n        \"zcr_var\",\r\n        \"harm_mean\",\r\n        \"harm_std\",\r\n        \"harm_var\",\r\n        \"perc_mean\",\r\n        \"perc_std\",\r\n        \"perc_var\",\r\n        \"frame_mean\",\r\n        \"frame_std\",\r\n        \"frame_var\"\r\n    ]; // all sound features, inputs\r\n\r\n\r\n    makeDatasetForTensors(data: object): Array<Array<any>> {\r\n        let dataInputs = [];\r\n        let dataOutputs = [];\r\n        for (const singleSong in data) {\r\n            let newArray = this.convertObjectToArray(data[singleSong]);\r\n            dataInputs.push(newArray[0]);\r\n            dataOutputs.push(newArray[1]);\r\n        }\r\n        return [\r\n            dataInputs,\r\n            dataOutputs\r\n        ];\r\n    };\r\n\r\n    convertObjectToArray(data: object): Array<Array<any>> {\r\n        // Converts the object to an iterable object\r\n        let singleFeature = [];\r\n        for(let [key, value] of Object.entries(data)) {\r\n            if (!Object.entries)\r\n                Object.entries = function( obj ){\r\n                    var ownProps = Object.keys( obj ),\r\n                        i = ownProps.length,\r\n                        resArray = new Array(i); // preallocate the Array\r\n                    while (i--)\r\n                        resArray[i] = [ownProps[i], obj[ownProps[i]]];\r\n                    if (i<ownProps.length-3) {\r\n                        return resArray;\r\n                    }\r\n                };\r\n            singleFeature.push(value); // add each feature to an array\r\n            // console.log(key, value); // \"first\", \"one\"\r\n        }\r\n        // Returns an array with\r\n        // [0] List of features\r\n        // [1] Label (\"relax\", \"calm\"...)\r\n        return [\r\n            singleFeature.splice(4), // I splice the array because the first values are id, song_name, class and label\r\n            singleFeature.splice(2, 1)\r\n        ]\r\n    };\r\n\r\n    normalizeData(originalData: object, arrayLikeData: object, type: string): Array<Array<number>> {\r\n\r\n        // console.log(originalData);\r\n\r\n        let normalizedData = [];\r\n        // Normalize data to a 0-1 range\r\n\r\n        // We get the range for each feature\r\n        // It returns an object like that:\r\n        // 0: {\r\n        //     feature: \"tempo\",\r\n        //         min: 53.83300781,\r\n        //         max: 198.7680288\r\n        // }\r\n        // ...\r\n        let featuresRange = this.getMinMaxValues(originalData);\r\n        // console.log(featuresRange);\r\n\r\n        if (type === \"inputs\") {\r\n            for (const song in arrayLikeData) {\r\n                let singleNormalizedData = [];\r\n                for (let i=0; i<arrayLikeData[song].length; i++) {\r\n                    let norm = this.normalize(arrayLikeData[song][i], featuresRange[i].min, featuresRange[i].max);\r\n                    singleNormalizedData.push(norm);\r\n                }\r\n                normalizedData.push(singleNormalizedData);\r\n            }\r\n            return normalizedData;\r\n        }\r\n\r\n    };\r\n\r\n    normalize(value: number, minValue: number, maxValue: number): number {\r\n        return (value-minValue)/(maxValue-minValue);\r\n    }\r\n\r\n    getMinMaxValues(data: object): object {\r\n\r\n        let featuresMinMax = []; // to store the min and max value used for normalizing the inputs\r\n\r\n        for (let i=0; i<this.featuresList.length; i++) {\r\n            let maxValue = 0;\r\n            let minValue = 0;\r\n            let counter = 0;\r\n\r\n            for (const song in data) {\r\n                let value = data[song][this.featuresList[i]];\r\n\r\n                if (counter === 0) {\r\n                    maxValue = value;\r\n                    minValue = value;\r\n                }\r\n                if (value > maxValue) {\r\n                    maxValue = value;\r\n                }\r\n                if (value < minValue) {\r\n                    minValue = value;\r\n                }\r\n                counter++;\r\n            }\r\n\r\n            featuresMinMax.push({\r\n                \"feature\": this.featuresList[i],\r\n                \"min\": minValue,\r\n                \"max\": maxValue\r\n            });\r\n        }\r\n\r\n        return featuresMinMax;\r\n\r\n    }\r\n\r\n\r\n    isIterable(obj) {\r\n        console.log(obj);\r\n        // checks for null and undefined\r\n        if (obj == null) {\r\n            return false;\r\n        }\r\n        return typeof obj[Symbol.iterator] === 'function';\r\n    }\r\n\r\n}","'use strict';\r\n\r\n// Import data\r\nimport * as dataset from \"../data/Emotion_data.json\";\r\nimport * as toClassify from \"../toClassify/Emotion_features.json\";\r\n\r\n// Import functions to convert data\r\nimport * as SD from \"./ShapeData\";\r\nconst ShapeData = new SD.ShapeData;\r\n\r\n\r\n// const Classifier = (p) => {\r\nlet data = {};\r\nlet songsToClassify = {};\r\nlet dataInputs = []; // The output of dataInputs[0] is dataOutputs[0]\r\nlet dataOutputs = []; // \"relax\", \"sad\", \"happy\"...\r\nlet normalizedData = [];\r\n\r\nsetup();\r\n\r\nfunction setup(): void {\r\n\r\n    loadJSON(dataset.default) // We have to use .default to load the url correctly with parcel\r\n        .then((jsonDataset) => {\r\n            data = JSON.parse(jsonDataset);\r\n            // let test = isIterable(data);\r\n            // console.log(test);\r\n            let newData = ShapeData.makeDatasetForTensors(data);\r\n            dataInputs = newData[0];\r\n            dataOutputs = newData[1];\r\n            // console.log(dataOutputs);\r\n            normalizedData = ShapeData.normalizeData(data, dataInputs, \"inputs\");\r\n            // makeInputs();\r\n            return loadJSON(toClassify.default);\r\n        })\r\n        .then((jsonSongs) => {\r\n            songsToClassify = JSON.parse(jsonSongs);\r\n            // for (let i=0; i<featuresList.length; i++) {\r\n            //     getMinMaxValues(featuresList[i]);\r\n            // }\r\n            // console.log(featuresMinMax);\r\n        })\r\n        .catch((err) => console.log(err));\r\n    // songsToClassify = loadJSON(toClassify, () => {\r\n\r\n}\r\n\r\n\r\n\r\nfunction makeInputs(): void {\r\n    let features = [];\r\n    for (let singleSong of data) {\r\n        for (let singleFeature of data[singleSong]) {\r\n            console.log(data[singleSong][singleFeature]);\r\n        }\r\n    }\r\n}\r\n\r\nfunction loadJSON(url: string): Promise<any> {\r\n\r\n    return new Promise((resolve, reject) => {\r\n        let xobj = new XMLHttpRequest();\r\n        xobj.overrideMimeType(\"application/json\");\r\n        xobj.open('GET', url, true); // Replace 'my_data' with the path to your file\r\n        xobj.onreadystatechange = () => {\r\n            if (xobj.readyState == 4 && xobj.status == 200) {\r\n                resolve(xobj.responseText);\r\n            }\r\n        };\r\n        xobj.send(null);\r\n        xobj.onerror = () => reject(xobj.statusText);\r\n    });\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n"]}