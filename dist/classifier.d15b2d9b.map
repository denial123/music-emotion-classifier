{"version":3,"sources":["scripts\\ShapeData.ts","scripts\\classifier.ts"],"names":[],"mappings":"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","file":"classifier.d15b2d9b.map","sourceRoot":"..","sourcesContent":["// Gathers all functions used to make the dataset ok for tensors\r\n\r\nexport class ShapeData {\r\n\r\n    featuresList = [\r\n        \"tempo\",\r\n        \"total_beats\",\r\n        \"average_beats\",\r\n        \"chroma_stft_mean\",\r\n        \"chroma_stft_std\",\r\n        \"chroma_stft_var\",\r\n        \"chroma_cq_mean\",\r\n        \"chroma_cq_std\",\r\n        \"chroma_cq_var\",\r\n        \"chroma_cens_mean\",\r\n        \"chroma_cens_std\",\r\n        \"chroma_cens_var\",\r\n        \"melspectrogram_mean\",\r\n        \"melspectrogram_std\",\r\n        \"melspectrogram_var\",\r\n        \"mfcc_mean\",\r\n        \"mfcc_std\",\r\n        \"mfcc_var\",\r\n        \"mfcc_delta_mean\",\r\n        \"mfcc_delta_std\",\r\n        \"mfcc_delta_var\",\r\n        \"rmse_mean\",\r\n        \"rmse_std\",\r\n        \"rmse_var\",\r\n        \"cent_mean\",\r\n        \"cent_std\",\r\n        \"cent_var\",\r\n        \"spec_bw_mean\",\r\n        \"spec_bw_std\",\r\n        \"spec_bw_var\",\r\n        \"contrast_mean\",\r\n        \"contrast_std\",\r\n        \"contrast_var\",\r\n        \"rolloff_mean\",\r\n        \"rolloff_std\",\r\n        \"rolloff_var\",\r\n        \"poly_mean\",\r\n        \"poly_std\",\r\n        \"poly_var\",\r\n        \"tonnetz_mean\",\r\n        \"tonnetz_std\",\r\n        \"tonnetz_var\",\r\n        \"zcr_mean\",\r\n        \"zcr_std\",\r\n        \"zcr_var\",\r\n        \"harm_mean\",\r\n        \"harm_std\",\r\n        \"harm_var\",\r\n        \"perc_mean\",\r\n        \"perc_std\",\r\n        \"perc_var\",\r\n        \"frame_mean\",\r\n        \"frame_std\",\r\n        \"frame_var\"\r\n    ]; // all sound features, inputs\r\n\r\n    // I want to be able to ignore certain features, like total_beats, because it could be irrelevant\r\n    // But for now it makes a mess with the arrays, so don't use it\r\n    featuresToIgnore = [\r\n        // \"total_beats\",\r\n        // \"chroma_stft_std\"\r\n    ];\r\n\r\n\r\n    makeDatasetForTensors(data: object): Array<Array<any>> {\r\n        let dataInputs = [];\r\n        let dataOutputs = [];\r\n        for (const singleSong in data) {\r\n            let newArray = this.convertObjectToArray(data[singleSong]);\r\n            const input = newArray.splice(4); // all the features\r\n            const output = newArray.splice(2, 1); // the label like \"relax\" or \"happy\"\r\n            dataInputs.push(input);\r\n            dataOutputs.push(output);\r\n        }\r\n\r\n        dataInputs = this.removeFeatures(dataInputs);\r\n\r\n        return [\r\n            dataInputs,\r\n            dataOutputs\r\n        ];\r\n    };\r\n\r\n    makeUnclassifiedSongsForTensors(originalData, songsToClassify: object) {\r\n        let enumFeatures = this.convertObjectToArray(songsToClassify);\r\n        let numberOfSongs = Object.keys(enumFeatures[0]).length;\r\n        let songNames = [];\r\n        let allFeatures = [];\r\n\r\n        for (let i=1; i<numberOfSongs+1; i++) {\r\n            let songName = \"\";\r\n            let singleSongFeatures = [];\r\n            for (let j=0; j<enumFeatures.length; j++) {\r\n                if (j === 0) {\r\n                    songName = enumFeatures[j][i];\r\n                } else {\r\n                    singleSongFeatures.push(enumFeatures[j][i]);\r\n                }\r\n            }\r\n            songNames.push(songName);\r\n            allFeatures.push(singleSongFeatures);\r\n        }\r\n\r\n        // console.log(\"norm\", this.normalizeData(originalData, allFeatures));\r\n\r\n        allFeatures = this.removeFeatures(allFeatures);\r\n\r\n        // We return the normalized features\r\n        return [\r\n            songNames,\r\n            this.normalizeData(originalData, allFeatures)\r\n        ];\r\n    }\r\n\r\n    getInputDim(): number {\r\n        return this.featuresList.length - this.featuresToIgnore.length;\r\n    }\r\n\r\n    removeFeatures(features: Array<Array<number>>): Array<Array<number>> {\r\n\r\n        for (const song in features) {\r\n            // console.log(features[song]);\r\n            for (let f=0; f<this.featuresToIgnore.length; f++) {\r\n                let featureIndex = this.featuresList.indexOf(this.featuresToIgnore[f]);\r\n                features[song].splice(featureIndex, 1);\r\n            }\r\n        }\r\n\r\n        return features;\r\n    }\r\n\r\n    convertObjectToArray(data: object): Array<Array<any>> {\r\n        // Converts the object to an iterable object\r\n        let newArray = [];\r\n        for(let [key, value] of Object.entries(data)) {\r\n            if (!Object.entries)\r\n                Object.entries = function( obj ){\r\n                    var ownProps = Object.keys( obj ),\r\n                        i = ownProps.length,\r\n                        resArray = new Array(i); // preallocate the Array\r\n                    while (i--)\r\n                        resArray[i] = [ownProps[i], obj[ownProps[i]]];\r\n                    if (i<ownProps.length-3) {\r\n                        return resArray;\r\n                    }\r\n                };\r\n            newArray.push(value); // add each feature to an array\r\n            // console.log(key, value); // \"first\", \"one\"\r\n        }\r\n        // Returns an array with\r\n        // [0] List of features\r\n        // [1] Label (\"relax\", \"calm\"...)\r\n        return newArray;\r\n    };\r\n\r\n    normalizeData(originalData: object, arrayLikeData: object): Array<Array<number>> {\r\n\r\n        // console.log(`originaldata: `, originalData);\r\n        // console.log(`arraylikedata: `, arrayLikeData);\r\n\r\n        let normalizedData = [];\r\n\r\n\r\n        let featuresRange = this.getMinMaxValues(originalData);\r\n        // console.log(featuresRange);\r\n\r\n        for (const song in arrayLikeData) {\r\n            let singleNormalizedData = [];\r\n            for (let i=0; i<arrayLikeData[song].length; i++) {\r\n                // console.log(`featuresRange[i]`, featuresRange[i].feature);\r\n                let norm = this.normalize(arrayLikeData[song][i], featuresRange[i].min, featuresRange[i].max);\r\n                // console.log(norm);\r\n                singleNormalizedData.push(norm);\r\n            }\r\n            normalizedData.push(singleNormalizedData);\r\n        }\r\n\r\n        // for (const song in arrayLikeData) {\r\n        //     let singleNormalizedData = [];\r\n        //     for (let i=0; i<arrayLikeData[song].length; i++) {\r\n        //         let norm = this.normalize(arrayLikeData[song][i], featuresRange[i].min, featuresRange[i].max);\r\n        //         console.log(norm);\r\n        //         singleNormalizedData.push(norm);\r\n        //     }\r\n        //     normalizedData.push(singleNormalizedData);\r\n        // }\r\n        return normalizedData;\r\n\r\n\r\n    };\r\n\r\n    normalize(value: number, minValue: number, maxValue: number): number {\r\n        // console.log(`value: ${value}`, `minValue: ${minValue}`, `maxValue: ${maxValue}`, `result: ${(value-minValue)/(maxValue-minValue)}`)\r\n        return (value-minValue)/(maxValue-minValue);\r\n    }\r\n\r\n    getMinMaxValues(data: object): object {\r\n\r\n        let featuresMinMax = []; // to store the min and max value used for normalizing the inputs\r\n\r\n        for (let i=0; i<this.featuresList.length; i++) {\r\n            let maxValue = 0;\r\n            let minValue = 0;\r\n            let counter = 0;\r\n\r\n            for (const song in data) {\r\n                let value = data[song][this.featuresList[i]];\r\n\r\n                if (counter === 0) {\r\n                    maxValue = value;\r\n                    minValue = value;\r\n                }\r\n                if (value > maxValue) {\r\n                    maxValue = value;\r\n                }\r\n                if (value < minValue) {\r\n                    minValue = value;\r\n                }\r\n                counter++;\r\n            }\r\n\r\n            featuresMinMax.push({\r\n                \"feature\": this.featuresList[i],\r\n                \"min\": minValue,\r\n                \"max\": maxValue\r\n            });\r\n        }\r\n\r\n        // console.log(`featuresMinMax:`, featuresMinMax)\r\n        return featuresMinMax;\r\n\r\n    }\r\n\r\n\r\n    isIterable(obj) {\r\n        console.log(obj);\r\n        // checks for null and undefined\r\n        if (obj == null) {\r\n            return false;\r\n        }\r\n        return typeof obj[Symbol.iterator] === 'function';\r\n    }\r\n\r\n}","'use strict';\r\n\r\n// -------- Options --------\r\n\r\n\r\n\r\n// Import data\r\nimport * as dataset from \"../data/Emotion_data.json\";\r\nimport * as toClassify from \"../toClassify/Emotion_features.json\";\r\n\r\n// Import functions to convert data\r\nimport * as SD from \"./ShapeData\";\r\nconst ShapeData = new SD.ShapeData;\r\n\r\n\r\nlet labelList = [\"sad\", \"happy\", \"relax\", \"angry\"];\r\n\r\ndocument.querySelector(`#submit`).addEventListener('click', () => {\r\n    // Get the values from HTML\r\n    const epochs = parseInt((<HTMLInputElement>document.querySelector(`#epochs`)).value);\r\n    const learningRate = parseFloat((<HTMLInputElement>document.querySelector(`#learningRate`)).value);\r\n    const validationSplit = parseFloat((<HTMLInputElement>document.querySelector(`#validationSplit`)).value);\r\n    const unitsHiddenLayer = parseInt((<HTMLInputElement>document.querySelector(`#epochs`)).value);\r\n    const hiddenLayerActivation = String((<HTMLInputElement>document.querySelector(`#hiddenLayerActivation`)).value);\r\n    const outputLayerActivation = String((<HTMLInputElement>document.querySelector(`#outputLayerActivation`)).value);\r\n\r\n    classify({\r\n        epochs: epochs,\r\n        learningRate: learningRate,\r\n        validationSplit: validationSplit,\r\n        unitsHiddenLayer: unitsHiddenLayer,\r\n        hiddenLayerActivation: hiddenLayerActivation,\r\n        outputLayerActivation: outputLayerActivation\r\n    });\r\n});\r\n\r\nclassify();\r\n\r\nfunction classify(options = {\r\n    epochs: 30,\r\n    learningRate: 0.3,\r\n    validationSplit: 0.2,\r\n    unitsHiddenLayer: 50,\r\n    hiddenLayerActivation: \"relu\",\r\n    outputLayerActivation: \"softmax\",\r\n}): void {\r\n\r\n\r\n    const epochs = options.epochs;\r\n    const learningRate = options.learningRate;\r\n    const validationSplit = options.validationSplit;\r\n    const unitsHiddenLayer = options.unitsHiddenLayer;\r\n    const hiddenLayerActivation = options.hiddenLayerActivation;\r\n    const outputLayerActivation = options.outputLayerActivation;\r\n\r\n    let data = {};\r\n    let songsToClassify = {};\r\n    let dataInputs = []; // The output of dataInputs[0] is dataOutputs[0]\r\n\r\n    let labels = []; // hot encoded values 0, 1, 2 or 3\r\n    let normalizedData = [];\r\n    let model;\r\n\r\n    // We have to use .default to load the url correctly with parcel\r\n    loadJSON(dataset.default)\r\n        .then((jsonDataset) => {\r\n            data = JSON.parse(jsonDataset);\r\n            return loadJSON(toClassify.default);\r\n        })\r\n        .then((jsonSongs) => {\r\n            songsToClassify = JSON.parse(jsonSongs);\r\n            let toClassify = ShapeData.makeUnclassifiedSongsForTensors(data, songsToClassify);\r\n            let songNames = toClassify[0];\r\n            let songFeatures = toClassify[1];\r\n            // console.log(songFeatures[0]);\r\n\r\n            // ---|-- Building the model ------|-----\r\n            // ---v----------------------------v-----\r\n\r\n            let newData = ShapeData.makeDatasetForTensors(data);\r\n            dataInputs = newData[0];\r\n            let dataOutputs = newData[1]; // the outputs are \"relax\", \"calm\"...\r\n\r\n            for (let i=0; i<dataOutputs.length; i++) {\r\n                // in the label list we put the hot encoded values like 0, 1, 2 or 3\r\n                labels.push(labelList.indexOf(dataOutputs[i][0]));\r\n            }\r\n\r\n            // Transform the value of each feature into a 0 to 1 range\r\n            normalizedData = ShapeData.normalizeData(data, dataInputs);\r\n            // console.log(normalizedData);\r\n\r\n            let xs = tf.tensor2d(normalizedData);\r\n            let labelsTensor = tf.tensor1d(labels, \"int32\"); // makes a tensor with the labels\r\n            let ys = tf.oneHot(labelsTensor, labelList.length); // defines the outputs\r\n            labelsTensor.dispose(); // for memory management, as we don't need anymore, we use dispose()\r\n\r\n            let inputDim = ShapeData.getInputDim();\r\n\r\n            model = tf.sequential();\r\n            let hiddenLayer = tf.layers.dense({\r\n                units: unitsHiddenLayer,\r\n                activation: hiddenLayerActivation,\r\n                inputDim: inputDim\r\n            });\r\n            let outputLayer = tf.layers.dense({\r\n                units: 4,\r\n                activation: outputLayerActivation\r\n            });\r\n            model.add(hiddenLayer);\r\n            model.add(outputLayer);\r\n\r\n            // Create an optimizer\r\n            const learningR = learningRate;\r\n            const myOptimizer = tf.train.sgd(learningR);\r\n\r\n            model.compile({\r\n                optimizer: myOptimizer,\r\n                loss: \"categoricalCrossentropy\",\r\n                metrics: [\"accuracy\"]\r\n            });\r\n\r\n            train(xs, ys).then( (result) => {\r\n                // console.log(result);\r\n                tf.tidy( () => {\r\n\r\n                    // Array to store the results\r\n                    let classifiedSongs = [];\r\n\r\n                    // Loop through all songs\r\n                    for (const song in songFeatures) {\r\n                        const toGuess = tf.tensor2d([songFeatures[song]]); // toGuess = input\r\n                        let results = model.predict(toGuess);\r\n                        let argMax = results.argMax(1);\r\n                        let index = argMax.dataSync()[0];\r\n                        let label = labelList[index];\r\n                        model.getWeights();\r\n                        classifiedSongs.push({\r\n                            songName: songNames[song],\r\n                            label: label,\r\n                            labelIndex: index\r\n                        });\r\n                        console.log(`I think that ${songNames[song]} is a ${label} song`);\r\n                    }\r\n\r\n                //    shows the final results\r\n                    console.log(`Classified songs:`, classifiedSongs);\r\n                });\r\n\r\n            });\r\n\r\n\r\n        })\r\n        .catch((err) => console.log(err));\r\n    // songsToClassify = loadJSON(toClassify, () => {\r\n\r\n    async function train(xs, ys) {\r\n\r\n        const options = {\r\n            epochs: epochs, // number of times it iterates over training data\r\n            validationSplit: validationSplit,\r\n            shuffle: true,\r\n            callbacks: {\r\n                onTrainBegin: () => console.log(\"training start\"),\r\n                onTrainEnd: () => console.log(\"training complete\"),\r\n                onEpochEnd: (num, logs) => {\r\n                    console.log(`Epoch: ${num}`);\r\n                    console.log(logs);\r\n                }\r\n            }\r\n            // shuffle\r\n        };\r\n\r\n        return await model.fit(xs, ys, options);\r\n    }\r\n\r\n    function makeInputs(): void {\r\n        let features = [];\r\n        for (let singleSong of data) {\r\n            for (let singleFeature of data[singleSong]) {\r\n                console.log(data[singleSong][singleFeature]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function loadJSON(url: string): Promise<any> {\r\n\r\n        return new Promise((resolve, reject) => {\r\n            let xobj = new XMLHttpRequest();\r\n            xobj.overrideMimeType(\"application/json\");\r\n            xobj.open('GET', url, true); // Replace 'my_data' with the path to your file\r\n            xobj.onreadystatechange = () => {\r\n                if (xobj.readyState == 4 && xobj.status == 200) {\r\n                    resolve(xobj.responseText);\r\n                }\r\n            };\r\n            xobj.send(null);\r\n            xobj.onerror = () => reject(xobj.statusText);\r\n        });\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n"]}