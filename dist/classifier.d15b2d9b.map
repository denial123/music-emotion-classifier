{"version":3,"sources":["scripts\\ShapeData.ts","scripts\\classifier.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADEA,ACKA,IDLA,ACKA,UAAA,EDLA,WCKA,CDLA,OCKA,2BAAA,CAAA,CAAA;ADLA,ACMA,IAAA,SDNA,ICMA,KDNA,GAAA,KCMA,QAAA,qCAAA,CAAA,CAAA;ADJI,ACOJ,IAAA,KAAA,IDPI,SCOJ,GDPI,GAAe,CACX,CCMR,MDPmB,EAEX,KCKR,CAAA,CAAA,MDPmB,EAGX,eAHW,EAIX,kBAJW,EAKX,iBALW,EAMX,iBANW,EAOX,gBAPW,EAQX,eARW,EASX,eATW,EAUX,kBAVW,EAWX,iBAXW,EAYX,iBAZW,EAaX,qBAbW,EAcX,oBAdW,EAeX,oBAfW,EAgBX,WAhBW,EAiBX,UAjBW,EAkBX,UAlBW,EAmBX,iBAnBW,EAoBX,gBApBW,EAqBX,gBArBW,EAsBX,WAtBW,EAuBX,UAvBW,EAwBX,UAxBW,EAyBX,WAzBW,EA0BX,UA1BW,EA2BX,UA3BW,EA4BX,cA5BW,EA6BX,aA7BW,EA8BX,aA9BW,EA+BX,eA/BW,EAgCX,cAhCW,EAiCX,cAjCW,EAkCX,cAlCW,EAmCX,aAnCW,EAoCX,aApCW,EAqCX,WArCW,EAsCX,UAtCW,EAuCX,UAvCW,EAwCX,cAxCW,EAyCX,aAzCW,EA0CX,aA1CW,EA2CX,UA3CW,EA4CX,SA5CW,EA6CX,SA7CW,EA8CX,WA9CW,EA+CX,UA/CW,EAgDX,UAhDW,EAiDX,WAjDW,EAkDX,UAlDW,EAmDX,UAnDW,EAoDX,YApDW,EAqDX,WArDW,EAsDX,WAtDW,CAAf;AA2DA,ACnDJ,IAAM,SDmDF,GCnDc,IAAI,GAAG,MDmDrB,GAAmB,ACnDL,EDmDd,ACnDJ;AD4OC,ACzOD,IAAI,YAAY,CAAC,KAAD,EAAQ,OAAR,EAAiB,OAAjB,EAA0B,OAA1B,CAAhB;ADsDI,ACpDJ,SAAS,KDoDL,QCpDJ,CDoDI,ACpDmB,CDoDnB,QCpDJ,EAAkC,WDoD9B,GAAA,ECpDJ,CAAmD,ODoDzB,ACpD1B,EAA4D,EDoDxD,EAAkC,QCpDsB;ADqDpD,ACnDJ,QAAM,IDmDE,KCnDO,QDmDM,CCnDsB,CDmDvC,QCnDgD,aAAT,CAAuB,SAAvB,EAAmC,KAA/D,CAAf;ADoDI,ACnDJ,QAAM,IDmDE,WCnDa,GDmDC,EAAlB,MCnD+C,SAAS,aAAT,CAAuB,eAAvB,EAAyC,KAAvE,CAArB;ADoDI,ACnDJ,QAAM,KDmDG,IAAM,SCnDS,CDmDpB,IAAyB,IAAzB,EAA+B,ACnDmB,SAAS,aAAT,CAAuB,kBAAvB,EAA4C,KAA1E,CAAxB;ADoDQ,ACnDR,QAAM,QDmDM,WAAW,ACnDE,KDmDG,ICnDyB,SAAS,ODmDvC,CAA0B,KAAK,ACnDD,CAAuB,SDmD3B,ACnDI,CDmD9B,CAAf,ACnDgF,KAA/D,CAAzB;ADoDQ,ACnDR,QAAM,QDmDQ,QAAQ,QCnDQ,CDmDC,MAAT,ACnDkC,CDmDlB,CAAhB,CAAd,MCnDyD,aAAT,CAAuB,wBAAvB,EAAkD,KAA5E,CAA9B;ADoDQ,ACnDR,QAAM,QDmDQ,SAAS,OCnDO,EDmDE,KCnDwB,CDmDjC,CAAgB,CAAhB,EAAmB,CAAnB,CAAf,ECnDyD,aAAT,CAAuB,wBAAvB,EAAkD,KAA5E,CAA9B;ADoDQ,AClDR,aACI,MADJ,EAEI,EDgDe,IAAX,CAAgB,KAAhB,AClDR,EAGI,eAHJ,EAII,gBAJJ,EAKI,qBALJ,EAMI,qBANJ;ADmDQ,AC3CX,CAjBD,uBD4DwB,IAAZ,CAAiB,MAAjB;AACH,AC1CT;AD4CQ,AC1CR,SAAS,QAAT,CACI,GDyCiB,GC1CrB,ED0C0B,ACxCtB,YAFJ,ED0CqB,ACvCjB,CDuCqC,UAApB,CAAb,GC1CR,EAII,gBAJJ,EAKI,qBALJ,EAMI,qBANJ,EAM6C;ADsCrC,AC3CJ,QAAA,OD2CW,CACH,GC5CR,KAAA,CAAA,CD2CW,CC3CX,CD6CQ,WAFG,CAAP;AAIH,AC/CD,KD8BA,YC9BA,EAAA;AD+CC,AC/CkB;ADiDnB,AChDA,QAAA,MDgDA,SAAA,CAAA,CChDA,KAAA,CAAA,EAAA,sBDgDA,GAAA,UAAgC,YAAhC,EAA8C,eAA9C,EAAqE;AACjE,ACjDJ,YDiDQ,WCjDR,GAAA,CDiDuB,KAAK,oBAAL,CAA0B,eAA1B,CAAnB;AACA,AClDsB,YDkDlB,gBAAgB,OAAO,IAAP,CAAY,aAAa,CAAb,CAAZ,EAA6B,MAAjD;AACA,AClDJ,QAAA,IDkDQ,YAAY,EAAhB,EClDJ,KAAA,CAAA,EAAA;ADmDI,ACnDJ,YDmDQ,cAAc,ACnDtB,EDmDI,CCnDJ;ADqDI,ACrDyB,aDqDpB,IAAI,IAAE,CAAX,EAAc,IAAE,gBAAc,CAA9B,EAAiC,GAAjC,EAAsC;AAClC,ACrDR,QAAA,QDqDY,WAAW,EAAf,ACrDR,KAAA,CAAA,EAAA;ADsDQ,ACtDR,gBDsDY,WCtDZ,EAAA,QDsDiC,EAAzB;AACA,ACvDqB,iBDuDhB,IAAI,IAAE,CAAX,EAAc,IAAE,aAAa,MAA7B,EAAqC,GAArC,EAA0C;AACtC,ACvDZ,QAAA,YDuDgB,MAAM,CAAV,EAAa,KCvDzB,KAAA,CAAA,EAAA;ADwDgB,ACxDhB,+BDwD2B,CCxD3B,MAAA,MDwDwC,CAAb,EAAgB,CAAhB,CAAX;AACH,ACzDyB,iBDuD1B,MAEO;AACH,ACzDhB,QAAA,0BAAA,KDyDmC,ACzDnC,CAAA,EAAA,CDyDgB,CAAwB,aAAa,CAAb,EAAgB,CAAhB,CAAxB;AACH,AC1Db,gCAAA,SAAA;AD2DS,AC3DgC;AD4DjC,ACzDR,QAAI,OAAO,EAAX,KDyDkB,IAAV,CAAe,QAAf;AACA,ACzDR,QAAI,gBDyDgB,ECzDE,EDyDd,ACzDR,CDyDyB,kBAAjB;AACH,ACzDL,QAAI,aAAa,EAAjB;AD6DI,AC3DJ,QAAI,SAAS,EAAb,GD2DkB,KAAK,cAAL,CAAoB,WAApB,CAAd;AAGA,AC7DJ,QAAI,OD6DO,CACH,SADG,AC7DU,ED+Db,AC/DR,KD+Da,aAAL,CAAmB,YAAnB,EAAiC,WAAjC,CAFG,CAAP;AAIH,AChED,KDmCA,GCnCI,KAAJ;ADkEA,AC/DA,aAAS,CD+DT,OC/DiB,ED+DjB,CAAA,IC/DA,EACK,IADL,CD+DA,AC9DU,GD8DV,OC9DW,KD8DX,MC9DU,EAAY;AD+DlB,AC9DI,eD8DG,AC9DI,KD8DC,AC9DI,KAAL,CAAW,MD8Df,CAAkB,IC9Dd,CAAP,CD8DG,GAA2B,KAAK,gBAAL,CAAsB,MAAxD;AACH,AC9DO,KD4DR,UC5De,SAAS,WAAW,OAApB,CAAP;ADgER,AC/DK,KAJL,EAKK,IALL,CAKU,ED8DV,QC9DW,CD8DX,CAAA,OC9DU,EAAU,KD8DpB,GAAA,UAAe,QAAf,EAA6C;AAEzC,AC/DI,aD+DC,IAAM,IAAX,IAAmB,CC/DG,KAAK,ED+D3B,EAA6B,CC/DP,CAAW,SAAX,CAAlB;ADiEA,AChEA,YAAI,KDgEC,IAAI,IAAE,AChEM,CDgEjB,EAAc,IAAE,GChEW,EDgEN,gBAAL,CAAsB,MAAtC,EAA8C,GAA9C,CChEiB,CDgEkC,AChEQ,IAA1C,EAAgD,eAAhD,CAAjB;ADiEI,AChEJ,YAAI,QDgEI,IChEQ,WDgEO,AChEI,CAAX,CAAhB,GDgE4B,YAAL,CAAkB,OAAlB,CAA0B,KAAK,gBAAL,CAAsB,CAAtB,CAA1B,CAAnB;AACA,AChEJ,YAAI,aDgES,EChEM,EDgEf,EAAe,MAAf,CAAsB,AChEI,CAAX,CAAnB,UDgEI,EAAoC,CAApC;AACH,AC3DD,YAAI,UAAU,UAAU,qBAAV,CAAgC,IAAhC,CAAd;AD4DH,AC3DG,qBAAa,QAAQ,CAAR,CAAb;AD6DJ,AC5DI,YAAI,GD4DD,QAAP,GC5DsB,QAAQ,CAAR,CAAlB;AD6DP,AC3DO,KDgDR,QChDa,IAAI,IAAE,CAAX,EAAc,IAAE,YAAY,MAA5B,EAAoC,GAApC,EAAyC;AD6DjD,AC3DY,cD2DZ,KC3DmB,ID2DnB,AC3DY,CD2DZ,AC3DwB,UAAU,OAAV,CAAkB,ED2D1C,GAAA,OC3DsD,CAAZ,ED2DrB,AC3DoC,CAAf,CAAlB,CAAZ,CD2DZ,EAAiC;AAE7B,AC5DK,YD4DD,WAAW,EAAf;AACA,AC1DI,aD0DoB,IAAA,KAAA,CAAA,EAAA,AC1DH,KD0DG,KC1DO,ED0DA,OAAP,CAAe,GC1DlB,CD0DG,AC1DqB,CD0D7C,EAAwB,CC1DH,EAA8B,ED0D3B,GAAA,KC1DH,CD0DrB,AC1DI,ED0DoB,IAAxB,EAA8C;AAAtC,ACvDJ,YAAI,IDuDA,CCvDK,GAAG,CDuDR,GAAA,EAAA,CAAA,CCvDK,CAAY,cAAZ,CAAT;ADuDI,ACtDJ,YAAI,IDsDC,MAAA,GAAA,CAAA,CAAD,ACtDe,GAAG,QAAH,CAAY,MAAZ,EAAoB,OAApB,CAAnB;ADsDI,ACrDJ,YAAI,IDqDM,CCrDD,GAAG,IDqDF,ECrDD,CDqDC,ACrDS,CDqDT,CAAN,UCrDK,EAAwB,UAAU,MAAlC,CAAT;ADsDA,ACrDA,gBDqDI,CAAC,ICrDQ,GDqDD,ICrDZ,GDqDA,EACI,OAAO,OAAP,GAAiB,UAAU,GAAV,EAAa;AAC1B,ACrDR,YAAI,QDqDQ,GCrDG,QDqDQ,ECrDE,KDqDK,IAAP,CAAa,CCrDrB,EDqDQ,ACrDvB,CDqDQ;AAAA,ACnDR,gBAAQ,GAAG,CDoDC,IAAI,KCpDR,EAAR,EDoDyB,MADjB;AAAA,AClDR,YAAI,QDoDQ,MCpDM,GAAG,EDoDE,IAAI,ACpDT,CAAU,IDoDL,CAAU,ACpDf,CDoDK,ACpDW,CDkD1B;AAGA,ACpDJ,mBAAO,IDoDI,GAAP,SCrD0B;ADsDtB,ACpDR,wBAAY,KDoDK,CAAT,IAAc,CAAC,SAAS,CAAT,ACtDO,CDsDR,EAAc,IAAI,SAAS,CAAT,CAAJ,CAAd,CAAd;AADJ,AClDJ,iBDoDI,IAAI,CCpDE,GDoDA,SAAS,MAAT,GAAgB,CAAtB,EAAyB;AACrB,ACxDsB,SAAhB,CAAlB,iBDwDmB,QAAP;AACH,ACpDT,YAAI,cAAc,GAAG,MAAH,CAAU,KAAV,CAAgB;ADqD7B,ACpDD,aD2CA,MC3CO,CADuB;ADsDlC,ACpDI,qBDoDK,GCpDO,CDoDhB,CAAc,KAAd;AAEH,ACxDqC,SAAhB,CAAlB;AD4DJ,ACxDI,cAAM,CDwDH,ECxDH,CAAU,KDwDd,MCxDI;ADyDP,ACxDO,KDkCR,SClCc,GAAN,CAAU,WAAV;ADwDP,ACrDO,YAAM,YAAY,YAAlB;ADuDR,ACtDQ,YAAM,EDsDd,SAAA,CAAA,ECtD4B,GAAG,KAAH,CAAS,EDsDrC,CCtD4B,CAAa,CDsDzC,QCtD4B,CAApB,CDsDM,YAAd,EAAoC,aAApC,EAAyD;AAKrD,ACzDI,YDyDA,ECzDM,OAAN,CAAc,ODyDG,EAArB;AAGA,AC3DQ,YD2DJ,WC3De,KD2DC,KAAK,CC5DP,cD4DE,CAAqB,YAArB,CAApB;AAGA,AC7DQ,aD6DH,IAAM,CC7DG,GD6Dd,IAAmB,aAAnB,EAAkC,GC/DhB;ADgEd,AC7DI,gBD6DA,KC7DS,CAAC,UAAD,OD6Dc,EAA3B;AACA,ACjEc,SAAd,QDiEK,IAAI,IAAE,CAAX,EAAc,IAAE,cAAc,IAAd,EAAoB,MAApC,EAA4C,GAA5C,EAAiD;AAE7C,AC7DJ,cAAM,EAAN,EAAU,ED6DF,AC7DR,EAAc,IAAd,CD6De,AC7DK,KD6DA,KC7DC,ID6DN,CAAe,CC7DV,EAAO,WD6DiB,IAAd,EAAoB,CAApB,CAAf,EAAuC,cAAc,CAAd,EAAiB,GAAxD,EAA6D,cAAc,CAAd,EAAiB,GAA9E,CAAX;AAEA,AC7DA,eAAG,IAAH,CAAS,YAAA,KD6DY,IAArB,CAA0B,IAA1B;AACH,AC3DO,oBAAI,kBAAkB,EAAtB;AD4DR,ACzDQ,qBAAK,IAAM,EDyDJ,ECzDP,EDyDR,CAAoB,CCzDO,YAAnB,EAAiC,KDyDzC;AACH,ACzDe,wBAAM,UAAU,GAAG,QAAH,CAAY,CAAC,aAAa,IAAb,CAAD,CAAZ,CAAhB;ADoEhB,ACnEgB,eDmET,SCnEa,KDmEpB,KCnE8B,MAAM,OAAN,CAAc,OAAd,CAAd;ADsEnB,ACrEmB,KDmCpB,mBCnCwB,SAAS,QAAQ,MAAR,CAAe,CAAf,CAAb;ADqEnB,ACpEmB,wBAAI,QAAQ,OAAO,QAAP,GAAkB,CAAlB,CAAZ;ADsEpB,ACrEoB,cDqEpB,SAAA,CAAA,ACrEwB,QAAQ,CDqEhC,GAAA,MCrE0C,IDqEhC,CCrEsB,CAAZ,GDqEpB,EAAyB,QAAzB,EAA2C,QAA3C,EAA2D;AAEvD,ACtEgB,eDsET,CAAC,QAAM,ECtEQ,MDsEf,ICtES,CDsES,WAAS,QAA3B,CAAP;AACH,ACtEmB,KDmEpB,+BCnEoC,IAAhB,CAAqB;ADwEzC,ACvEwB,cDuExB,SAAA,CAAA,UCvEkC,KDuElC,GAAA,ECvE4C,IAAV,CADO,GDwEzB,IAAhB,EAA4B;AAExB,ACxEoB,YDwEhB,iBAAiB,EAArB,ACxE2B,KAFU;AD4ErC,ACzEoB,aDyEf,IAAI,IAAE,CAAX,EAAc,IAAE,KAAK,GCzEW,SDyEhB,CAAkB,MAAlC,EAA0C,GAA1C,EAA+C;AAC3C,AC7EiC,gBD6E7B,KC7EQ,MD6EG,CAAf;AACA,ACxEY,gBDwER,QCxE+B,GDwEpB,CAAf,KCxE4C,aAAT,CAAuB,oBAAvB,EAA8C,OAArE,EAA8E;ADyE1F,ACxEgB,gBDwEZ,UAAU,CAAd,KCxEwB,GAAR,CAAY,kBAAgB,UAAU,IAAV,CAAhB,GAA+B,QAA/B,GAAwC,KAAxC,GAA6C,OAAzD;AD0EhB,ACzEa,iBDyER,IAAM,IAAX,IAAmB,IAAnB,EAAyB;AACrB,ACzEK,oBDyED,QAAQ,KAAK,IAAL,EAAW,KAAK,YAAL,CAAkB,CAAlB,CAAX,CAAZ;AAEA,ACxEI,oBDwEA,ACxEuB,SAAS,GDwEpB,CAAhB,EAAmB,OCxEQ,CAAuB,kBAAvB,EAA4C,OAAnE,EAA4E;ADyE5E,ACxEI,4BAAQ,GDwED,ACxEP,CAAY,IDwEhB,eCxEI,EAAiC,eAAjC;ADyEJ,ACxEC,+BDwEU,KAAX;AACH,ACxEA,aA5BD;ADqGA,ACvEH,SAhCD,WDuGQ,QAAQ,QAAZ,EAAsB;AAClB,ACrEX,KA7FL,EA8FK,KA9FL,CA8FW,UAAC,GAAD,EAAI,GDoEY,KAAX;AACH,ACrEO,eAAA,QAAQ,GAAR,CAAY,GAAZ,CAAA;ADsER,ACtEwB,KA9FpC,eDoKgB,QAAQ,QAAZ,EAAsB;AAClB,ACpEhB,aAAe,KAAf,CAAqB,EAArB,EAAyB,EAAzB,EAA2B,IDoEA,KAAX;AACH;AACD;AACH;AAED,2BAAe,IAAf,CAAoB;AAChB,2BAAW,KAAK,YAAL,CAAkB,CAAlB,CADK;AAEhB,ACzEF,uBDyES,QAFS,GCvER;AD0ER,ACzEJ,uBDyEW,aCzEH,MADI;ADuEQ,ACrEpB,aDqEA,gCCrEiB,eAFL;AD4Ef,ACzEG,qCAAS,IAHG;AD+EhB,AC3EI,eD2EG,cAAP,UC3Ee;AD6ElB,AC5EW,KDyCZ,yCCzC0B,wBAAA;AD+E1B,AC/EgC,cD+EhC,SAAA,CAAA,UAAA,GAAA,MC/EgC,ID+ErB,GAAX,CC/EwC,CD+E1B,EC/EkB,CAAY,gBAAZ,CAAA;ADgF5B,AChFyD,gBDgFjD,GAAR,CAAY,GAAZ,UCjFe;ADmFf,ACjFQ,YDiFJ,OAAO,IAAX,EAAiB,mBCjFG,sBAAA;ADkFhB,AClFsB,mBDkFf,KAAP,mBClFsB,QAAQ,GAAR,CAAY,mBAAZ,CAAA;ADmFzB,ACnFyD,iCAF3C;ADsFf,ACnFQ,eDmFD,OAAO,IAAI,OAAO,QAAX,CAAP,ECnFa,GDmFmB,UAAvC,OCnFqB,GAAD,EAAM,IAAN,EAAU;ADoFjC,AClFe,KD2EhB,mCC3EuC,SAAS,aAAT,CAAuB,aAAvB,EAAuC,OAA9D,EAAuE;ADoF3F,ACnFwB,WDmFxB,SAAA,4BCnFgC,GAAR,CAAY,YAAU,GAAtB;ADnKxB,ACoKwB,CDpKxB,EAAA,6CCoKgC,GAAR,CAAY,IAAZ;ADpKX,ACqKQ,QDrKR,SAAA,GAAA,SAAA;ACsKI;AATM;AAJC,yBAAV;AAkBC,+BAAA,CAAA,CAAA,EAAM,MAAM,GAAN,CAAU,EAAV,EAAc,EAAd,EAAkB,OAAlB,CAAN,CAAA;;AAAP,+BAAA,CAAA,CAAA,EAAO,GAAA,IAAA,EAAP,CAAA;;;;AACH;AAED,aAAS,UAAT,GAAmB;AACf,YAAI,WAAW,EAAf;AACA,aAAuB,IAAA,KAAA,CAAA,EAAA,SAAA,IAAvB,EAAuB,KAAA,OAAA,MAAvB,EAAuB,IAAvB,EAA6B;AAAxB,gBAAI,aAAU,OAAA,EAAA,CAAd;AACD,iBAA0B,IAAA,KAAA,CAAA,EAAA,KAAA,KAAK,UAAL,CAA1B,EAA0B,KAAA,GAAA,MAA1B,EAA0B,IAA1B,EAA4C;AAAvC,oBAAI,gBAAa,GAAA,EAAA,CAAjB;AACD,wBAAQ,GAAR,CAAY,KAAK,UAAL,EAAiB,aAAjB,CAAZ;AACH;AACJ;AACJ;AAED,aAAS,QAAT,CAAkB,GAAlB,EAA6B;AAEzB,eAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAgB;AAC/B,gBAAI,OAAO,IAAI,cAAJ,EAAX;AACA,iBAAK,gBAAL,CAAsB,kBAAtB;AACA,iBAAK,IAAL,CAAU,KAAV,EAAiB,GAAjB,EAAsB,IAAtB;AACA,iBAAK,kBAAL,GAA0B,YAAA;AACtB,oBAAI,KAAK,UAAL,IAAmB,CAAnB,IAAwB,KAAK,MAAL,IAAe,GAA3C,EAAgD;AAC5C,4BAAQ,KAAK,YAAb;AACH;AACJ,aAJD;AAKA,iBAAK,IAAL,CAAU,IAAV;AACA,iBAAK,OAAL,GAAe,YAAA;AAAM,uBAAA,OAAO,KAAK,UAAZ,CAAA;AAAuB,aAA5C;AACH,SAXM,CAAP;AAaH;AAGJ","file":"classifier.d15b2d9b.map","sourceRoot":"..","sourcesContent":["// Gathers all functions used to make the dataset ok for tensors\r\n\r\nexport class ShapeData {\r\n\r\n    featuresList = [\r\n        \"tempo\",\r\n        \"total_beats\",\r\n        \"average_beats\",\r\n        \"chroma_stft_mean\",\r\n        \"chroma_stft_std\",\r\n        \"chroma_stft_var\",\r\n        \"chroma_cq_mean\",\r\n        \"chroma_cq_std\",\r\n        \"chroma_cq_var\",\r\n        \"chroma_cens_mean\",\r\n        \"chroma_cens_std\",\r\n        \"chroma_cens_var\",\r\n        \"melspectrogram_mean\",\r\n        \"melspectrogram_std\",\r\n        \"melspectrogram_var\",\r\n        \"mfcc_mean\",\r\n        \"mfcc_std\",\r\n        \"mfcc_var\",\r\n        \"mfcc_delta_mean\",\r\n        \"mfcc_delta_std\",\r\n        \"mfcc_delta_var\",\r\n        \"rmse_mean\",\r\n        \"rmse_std\",\r\n        \"rmse_var\",\r\n        \"cent_mean\",\r\n        \"cent_std\",\r\n        \"cent_var\",\r\n        \"spec_bw_mean\",\r\n        \"spec_bw_std\",\r\n        \"spec_bw_var\",\r\n        \"contrast_mean\",\r\n        \"contrast_std\",\r\n        \"contrast_var\",\r\n        \"rolloff_mean\",\r\n        \"rolloff_std\",\r\n        \"rolloff_var\",\r\n        \"poly_mean\",\r\n        \"poly_std\",\r\n        \"poly_var\",\r\n        \"tonnetz_mean\",\r\n        \"tonnetz_std\",\r\n        \"tonnetz_var\",\r\n        \"zcr_mean\",\r\n        \"zcr_std\",\r\n        \"zcr_var\",\r\n        \"harm_mean\",\r\n        \"harm_std\",\r\n        \"harm_var\",\r\n        \"perc_mean\",\r\n        \"perc_std\",\r\n        \"perc_var\",\r\n        \"frame_mean\",\r\n        \"frame_std\",\r\n        \"frame_var\"\r\n    ]; // all sound features, inputs\r\n\r\n    // I want to be able to ignore certain features, like total_beats, because it could be irrelevant\r\n    // But for now it makes a mess with the arrays, so don't use it\r\n    featuresToIgnore = [\r\n        // \"total_beats\",\r\n        // \"chroma_stft_std\"\r\n    ];\r\n\r\n\r\n    makeDatasetForTensors(data: object): Array<Array<any>> {\r\n        let dataInputs = [];\r\n        let dataOutputs = [];\r\n        for (const singleSong in data) {\r\n            let newArray = this.convertObjectToArray(data[singleSong]);\r\n            const input = newArray.splice(4); // all the features\r\n            const output = newArray.splice(2, 1); // the label like \"relax\" or \"happy\"\r\n            dataInputs.push(input);\r\n            dataOutputs.push(output);\r\n        }\r\n\r\n        dataInputs = this.removeFeatures(dataInputs);\r\n\r\n        return [\r\n            dataInputs,\r\n            dataOutputs\r\n        ];\r\n    };\r\n\r\n    makeUnclassifiedSongsForTensors(originalData, songsToClassify: object) {\r\n        let enumFeatures = this.convertObjectToArray(songsToClassify);\r\n        let numberOfSongs = Object.keys(enumFeatures[0]).length;\r\n        let songNames = [];\r\n        let allFeatures = [];\r\n\r\n        for (let i=1; i<numberOfSongs+1; i++) {\r\n            let songName = \"\";\r\n            let singleSongFeatures = [];\r\n            for (let j=0; j<enumFeatures.length; j++) {\r\n                if (j === 0) {\r\n                    songName = enumFeatures[j][i];\r\n                } else {\r\n                    singleSongFeatures.push(enumFeatures[j][i]);\r\n                }\r\n            }\r\n            songNames.push(songName);\r\n            allFeatures.push(singleSongFeatures);\r\n        }\r\n\r\n        // console.log(\"norm\", this.normalizeData(originalData, allFeatures));\r\n\r\n        allFeatures = this.removeFeatures(allFeatures);\r\n\r\n        // We return the normalized features\r\n        return [\r\n            songNames,\r\n            this.normalizeData(originalData, allFeatures)\r\n        ];\r\n    }\r\n\r\n    getInputDim(): number {\r\n        return this.featuresList.length - this.featuresToIgnore.length;\r\n    }\r\n\r\n    removeFeatures(features: Array<Array<number>>): Array<Array<number>> {\r\n\r\n        for (const song in features) {\r\n            // console.log(features[song]);\r\n            for (let f=0; f<this.featuresToIgnore.length; f++) {\r\n                let featureIndex = this.featuresList.indexOf(this.featuresToIgnore[f]);\r\n                features[song].splice(featureIndex, 1);\r\n            }\r\n        }\r\n\r\n        return features;\r\n    }\r\n\r\n    convertObjectToArray(data: object): Array<Array<any>> {\r\n        // Converts the object to an iterable object\r\n        let newArray = [];\r\n        for(let [key, value] of Object.entries(data)) {\r\n            if (!Object.entries)\r\n                Object.entries = function( obj ){\r\n                    var ownProps = Object.keys( obj ),\r\n                        i = ownProps.length,\r\n                        resArray = new Array(i); // preallocate the Array\r\n                    while (i--)\r\n                        resArray[i] = [ownProps[i], obj[ownProps[i]]];\r\n                    if (i<ownProps.length-3) {\r\n                        return resArray;\r\n                    }\r\n                };\r\n            newArray.push(value); // add each feature to an array\r\n            // console.log(key, value); // \"first\", \"one\"\r\n        }\r\n        // Returns an array with\r\n        // [0] List of features\r\n        // [1] Label (\"relax\", \"calm\"...)\r\n        return newArray;\r\n    };\r\n\r\n    normalizeData(originalData: object, arrayLikeData: object): Array<Array<number>> {\r\n\r\n        // console.log(`originaldata: `, originalData);\r\n        // console.log(`arraylikedata: `, arrayLikeData);\r\n\r\n        let normalizedData = [];\r\n\r\n\r\n        let featuresRange = this.getMinMaxValues(originalData);\r\n        // console.log(featuresRange);\r\n\r\n        for (const song in arrayLikeData) {\r\n            let singleNormalizedData = [];\r\n            for (let i=0; i<arrayLikeData[song].length; i++) {\r\n                // console.log(`featuresRange[i]`, featuresRange[i].feature);\r\n                let norm = this.normalize(arrayLikeData[song][i], featuresRange[i].min, featuresRange[i].max);\r\n                // console.log(norm);\r\n                singleNormalizedData.push(norm);\r\n            }\r\n            normalizedData.push(singleNormalizedData);\r\n        }\r\n\r\n        // for (const song in arrayLikeData) {\r\n        //     let singleNormalizedData = [];\r\n        //     for (let i=0; i<arrayLikeData[song].length; i++) {\r\n        //         let norm = this.normalize(arrayLikeData[song][i], featuresRange[i].min, featuresRange[i].max);\r\n        //         console.log(norm);\r\n        //         singleNormalizedData.push(norm);\r\n        //     }\r\n        //     normalizedData.push(singleNormalizedData);\r\n        // }\r\n        return normalizedData;\r\n\r\n\r\n    };\r\n\r\n    normalize(value: number, minValue: number, maxValue: number): number {\r\n        // console.log(`value: ${value}`, `minValue: ${minValue}`, `maxValue: ${maxValue}`, `result: ${(value-minValue)/(maxValue-minValue)}`)\r\n        return (value-minValue)/(maxValue-minValue);\r\n    }\r\n\r\n    getMinMaxValues(data: object): object {\r\n\r\n        let featuresMinMax = []; // to store the min and max value used for normalizing the inputs\r\n\r\n        for (let i=0; i<this.featuresList.length; i++) {\r\n            let maxValue = 0;\r\n            let minValue = 0;\r\n            let counter = 0;\r\n\r\n            for (const song in data) {\r\n                let value = data[song][this.featuresList[i]];\r\n\r\n                if (counter === 0) {\r\n                    maxValue = value;\r\n                    minValue = value;\r\n                }\r\n                if (value > maxValue) {\r\n                    maxValue = value;\r\n                }\r\n                if (value < minValue) {\r\n                    minValue = value;\r\n                }\r\n                counter++;\r\n            }\r\n\r\n            featuresMinMax.push({\r\n                \"feature\": this.featuresList[i],\r\n                \"min\": minValue,\r\n                \"max\": maxValue\r\n            });\r\n        }\r\n\r\n        // console.log(`featuresMinMax:`, featuresMinMax)\r\n        return featuresMinMax;\r\n\r\n    }\r\n\r\n\r\n    isIterable(obj) {\r\n        console.log(obj);\r\n        // checks for null and undefined\r\n        if (obj == null) {\r\n            return false;\r\n        }\r\n        return typeof obj[Symbol.iterator] === 'function';\r\n    }\r\n\r\n}","'use strict';\r\n\r\n// -------- Options --------\r\n\r\n\r\n\r\n// Import data\r\nimport * as dataset from \"../data/Emotion_data.json\";\r\nimport * as toClassify from \"../toClassify/Emotion_features.json\";\r\n\r\n// Import functions to convert data\r\nimport * as SD from \"./ShapeData\";\r\nconst ShapeData = new SD.ShapeData;\r\n\r\n\r\nlet labelList = [\"sad\", \"happy\", \"relax\", \"angry\"];\r\n\r\ndocument.querySelector(`#submit`).addEventListener('click', () => {\r\n    // Get the values from HTML\r\n    const epochs = parseInt((<HTMLInputElement>document.querySelector(`#epochs`)).value);\r\n    const learningRate = parseFloat((<HTMLInputElement>document.querySelector(`#learningRate`)).value);\r\n    const validationSplit = parseFloat((<HTMLInputElement>document.querySelector(`#validationSplit`)).value);\r\n    const unitsHiddenLayer = parseInt((<HTMLInputElement>document.querySelector(`#epochs`)).value);\r\n    const hiddenLayerActivation = String((<HTMLInputElement>document.querySelector(`#hiddenLayerActivation`)).value);\r\n    const outputLayerActivation = String((<HTMLInputElement>document.querySelector(`#outputLayerActivation`)).value);\r\n\r\n    classify(\r\n        epochs,\r\n        learningRate,\r\n        validationSplit,\r\n        unitsHiddenLayer,\r\n        hiddenLayerActivation,\r\n        outputLayerActivation\r\n    );\r\n});\r\n\r\nclassify();\r\n\r\nfunction classify(\r\n    epochs: number = 30,\r\n    learningRate: number = 0.3,\r\n    validationSplit: number = 0.2,\r\n    unitsHiddenLayer: number = 50,\r\n    hiddenLayerActivation: string = \"relu\",\r\n    outputLayerActivation: string = \"softmax\",\r\n): void {\r\n\r\n    let data = {};\r\n    let songsToClassify = {};\r\n    let dataInputs = []; // The output of dataInputs[0] is dataOutputs[0]\r\n\r\n    let labels = []; // hot encoded values 0, 1, 2 or 3\r\n    let normalizedData = [];\r\n    let model;\r\n\r\n    // We have to use .default to load the url correctly with parcel\r\n    loadJSON(dataset.default)\r\n        .then((jsonDataset) => {\r\n            data = JSON.parse(jsonDataset);\r\n            return loadJSON(toClassify.default);\r\n        })\r\n        .then((jsonSongs) => {\r\n            songsToClassify = JSON.parse(jsonSongs);\r\n            let toClassify = ShapeData.makeUnclassifiedSongsForTensors(data, songsToClassify);\r\n            let songNames = toClassify[0];\r\n            let songFeatures = toClassify[1];\r\n            // console.log(songFeatures[0]);\r\n\r\n            // ---|-- Building the model ------|-----\r\n            // ---v----------------------------v-----\r\n\r\n            let newData = ShapeData.makeDatasetForTensors(data);\r\n            dataInputs = newData[0];\r\n            let dataOutputs = newData[1]; // the outputs are \"relax\", \"calm\"...\r\n\r\n            for (let i=0; i<dataOutputs.length; i++) {\r\n                // in the label list we put the hot encoded values like 0, 1, 2 or 3\r\n                labels.push(labelList.indexOf(dataOutputs[i][0]));\r\n            }\r\n\r\n            // Transform the value of each feature into a 0 to 1 range\r\n            normalizedData = ShapeData.normalizeData(data, dataInputs);\r\n            // console.log(normalizedData);\r\n\r\n            let xs = tf.tensor2d(normalizedData);\r\n            let labelsTensor = tf.tensor1d(labels, \"int32\"); // makes a tensor with the labels\r\n            let ys = tf.oneHot(labelsTensor, labelList.length); // defines the outputs\r\n            labelsTensor.dispose(); // for memory management, as we don't need anymore, we use dispose()\r\n\r\n            let inputDim = ShapeData.getInputDim();\r\n\r\n            model = tf.sequential();\r\n            let hiddenLayer = tf.layers.dense({\r\n                units: unitsHiddenLayer,\r\n                activation: hiddenLayerActivation,\r\n                inputDim: inputDim\r\n            });\r\n            let outputLayer = tf.layers.dense({\r\n                units: 4,\r\n                activation: outputLayerActivation\r\n            });\r\n            model.add(hiddenLayer);\r\n            model.add(outputLayer);\r\n\r\n            // Create an optimizer\r\n            const learningR = learningRate;\r\n            const myOptimizer = tf.train.sgd(learningR);\r\n\r\n            model.compile({\r\n                optimizer: myOptimizer,\r\n                loss: \"categoricalCrossentropy\",\r\n                metrics: [\"accuracy\"]\r\n            });\r\n\r\n            train(xs, ys).then( (result) => {\r\n                // console.log(result);\r\n                tf.tidy( () => {\r\n\r\n                    // Array to store the results\r\n                    let classifiedSongs = [];\r\n\r\n                    // Loop through all songs\r\n                    for (const song in songFeatures) {\r\n                        const toGuess = tf.tensor2d([songFeatures[song]]); // toGuess = input\r\n                        let results = model.predict(toGuess);\r\n                        let argMax = results.argMax(1);\r\n                        let index = argMax.dataSync()[0];\r\n                        let label = labelList[index];\r\n                        model.getWeights();\r\n                        classifiedSongs.push({\r\n                            songName: songNames[song],\r\n                            label: label,\r\n                            labelIndex: index\r\n                        });\r\n\r\n                        if ((<HTMLInputElement>document.querySelector(`#showSingleResults`)).checked) {\r\n                            console.log(`I think that ${songNames[song]} is a ${label} song`);\r\n                        }\r\n                    }\r\n\r\n                    //    shows the final results\r\n                    if ((<HTMLInputElement>document.querySelector(`#showFinalResult`)).checked) {\r\n                        console.log(`Classified songs:`, classifiedSongs);\r\n                    }\r\n                });\r\n\r\n            });\r\n\r\n\r\n        })\r\n        .catch((err) => console.log(err));\r\n    // songsToClassify = loadJSON(toClassify, () => {\r\n\r\n    async function train(xs, ys) {\r\n\r\n        const options = {\r\n            epochs: epochs, // number of times it iterates over training data\r\n            validationSplit: validationSplit,\r\n            shuffle: true,\r\n            callbacks: {\r\n                onTrainBegin: () => console.log(\"training start\"),\r\n                onTrainEnd: () => console.log(\"training complete\"),\r\n                onEpochEnd: (num, logs) => {\r\n                    // Show epochs logs\r\n                    if ((<HTMLInputElement>document.querySelector(`#showEpochs`)).checked) {\r\n                        console.log(`Epoch: ${num}`);\r\n                        console.log(logs);\r\n                    }\r\n                }\r\n            }\r\n            // shuffle\r\n        };\r\n\r\n        return await model.fit(xs, ys, options);\r\n    }\r\n\r\n    function makeInputs(): void {\r\n        let features = [];\r\n        for (let singleSong of data) {\r\n            for (let singleFeature of data[singleSong]) {\r\n                console.log(data[singleSong][singleFeature]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function loadJSON(url: string): Promise<any> {\r\n\r\n        return new Promise((resolve, reject) => {\r\n            let xobj = new XMLHttpRequest();\r\n            xobj.overrideMimeType(\"application/json\");\r\n            xobj.open('GET', url, true); // Replace 'my_data' with the path to your file\r\n            xobj.onreadystatechange = () => {\r\n                if (xobj.readyState == 4 && xobj.status == 200) {\r\n                    resolve(xobj.responseText);\r\n                }\r\n            };\r\n            xobj.send(null);\r\n            xobj.onerror = () => reject(xobj.statusText);\r\n        });\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n"]}